<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Medal Library - CSS Transform Approach</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .subtitle {
            text-align: center;
            opacity: 0.8;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        /* Main Medal Display */
        .medal-display {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            margin-bottom: 30px;
        }
        
        .medal-title {
            text-align: center;
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: bold;
            min-height: 28px;
        }
        
        .scene {
            width: 100%;
            height: 400px;
            perspective: 1000px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            z-index: 10;
            flex-direction: column;
            gap: 15px;
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 16px;
            opacity: 0.9;
        }
        
        .medal-3d {
            width: 300px;
            height: 300px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.05s linear;
            cursor: pointer;
        }
        
        .medal-3d.flipping {
            transition: transform 1.2s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        .medal-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            overflow: hidden;
        }
        
        /* Shine container with mask - stationary */
        .shine-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 10;
            -webkit-mask-image: var(--lightness-mask, none);
            mask-image: var(--lightness-mask, none);
            -webkit-mask-size: 100% 100%;
            mask-size: 100% 100%;
            -webkit-mask-position: 0 0;
            mask-position: 0 0;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            opacity: var(--shine-opacity, 0);
        }
        
        /* Shine gradient - moving inside container */
        .shine-gradient {
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: var(--shine-gradient, linear-gradient(135deg, 
                transparent 0%,
                transparent 45%,
                rgba(255,255,255,0.8) 48%,
                rgba(255,255,255,1) 50%,
                rgba(255,255,255,0.8) 52%,
                transparent 55%,
                transparent 100%));
            transform: translateX(var(--shine-position, -150%));
            filter: var(--blur-amount, blur(15px));
            will-change: transform;
        }
        
        .medal-front {
            transform: translateZ(15px);
        }
        
        .medal-back {
            transform: translateZ(-15px) rotateY(180deg);
        }
        
        .medal-edge {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.1s linear;
        }
        
        .edge-container {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            pointer-events: none;
        }
        
        .edge-segment {
            position: absolute;
            left: 50%;
            top: 50%;
            transform-style: preserve-3d;
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.3), 
                        inset 0 -1px 1px rgba(0,0,0,0.3);
        }
        
        /* Thumbnail Library */
        .library-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            margin-bottom: 30px;
        }
        
        .library-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .thumbnail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .thumbnail {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            overflow: hidden;
            position: relative;
        }
        
        .thumbnail:hover {
            transform: translateY(-3px);
            background: rgba(255, 255, 255, 0.15);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .thumbnail.active {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        .thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            padding: 10px;
        }
        
        .thumbnail-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            font-size: 10px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .thumbnail:hover .thumbnail-name {
            opacity: 1;
        }
        
        /* Controls */
        .controls {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .value-display {
            min-width: 60px;
            text-align: right;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        button {
            background: white;
            color: #1e3c72;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-right: 10px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .info-box {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .info-box h3 {
            margin-bottom: 10px;
            color: #ffd700;
        }
        
        hr {
            margin: 25px 0;
            border: none;
            border-top: 1px solid rgba(255,255,255,0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÖ 3D Medal Library</h1>
        <p class="subtitle">Click any thumbnail to load a different medal</p>
        
        <!-- Main Medal Display -->
        <div class="medal-display">
            <div class="medal-title" id="currentMedalName">Loading...</div>
            <div class="scene">
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div class="loading-text">Generating 3D medal...</div>
                </div>
                <div class="medal-3d" id="medal">
                    <div class="medal-front medal-face"></div>
                    <div class="edge-container"></div>
                    <div class="medal-back medal-face"></div>
                </div>
            </div>
        </div>
        
        <!-- Thumbnail Library -->
        <div class="library-section">
            <div class="library-title">
                üìö Medal Library
                <span style="opacity: 0.7; font-size: 14px; font-weight: normal;" id="imageCount"></span>
            </div>
            <div class="thumbnail-grid" id="thumbnailGrid">
                <!-- Thumbnails will be dynamically inserted here -->
            </div>
        </div>
        
        <!-- Controls -->
        <div class="controls">
            <div class="control-group">
                <label>Rotation Angle (Y-axis)</label>
                <div class="control-row">
                    <input type="range" id="rotation" min="-180" max="180" value="0" step="1">
                    <span class="value-display"><span id="rotationValue">0</span>¬∞</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Medal Thickness</label>
                <div class="control-row">
                    <input type="range" id="thickness" min="5" max="50" value="15" step="1">
                    <span class="value-display"><span id="thicknessValue">15</span>px</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Animation Speed</label>
                <div class="control-row">
                    <input type="range" id="speed" min="0.5" max="5" value="2" step="0.1">
                    <span class="value-display"><span id="speedValue">2.0</span>x</span>
                </div>
            </div>
            
            <div class="control-group">
                <div class="button-group">
                    <button id="animate">‚ñ∂ Animate Rotation</button>
                    <button id="stop">‚è∏ Stop</button>
                    <button id="reset">‚Ü∫ Reset</button>
                </div>
            </div>
            
            <hr>
            
            <h3 style="margin-bottom: 15px; color: #ffd700;">‚ú® Shine Effect Controls</h3>
            
            <div class="control-group">
                <label>Shine Angle (gradient direction)</label>
                <div class="control-row">
                    <input type="range" id="shineAngle" min="0" max="360" value="135" step="1">
                    <span class="value-display"><span id="shineAngleValue">135</span>¬∞</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Blur Amount</label>
                <div class="control-row">
                    <input type="range" id="shineBlur" min="0" max="50" value="15" step="1">
                    <span class="value-display"><span id="shineBlurValue">15</span>px</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Mask Contrast Power</label>
                <div class="control-row">
                    <input type="range" id="maskContrast" min="0.5" max="5" value="1.5" step="0.1">
                    <span class="value-display"><span id="maskContrastValue">1.5</span></span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Max Shine Opacity</label>
                <div class="control-row">
                    <input type="range" id="shineOpacity" min="0" max="1" value="0.8" step="0.05">
                    <span class="value-display"><span id="shineOpacityValue">0.80</span></span>
                </div>
            </div>
            
            <div class="control-group">
                <div class="button-group">
                    <button id="regenerateMask">üîÑ Regenerate Shine Mask</button>
                </div>
            </div>
            
            <div class="info-box">
                <h3>‚ú® How to Use</h3>
                <ul style="margin-left: 20px; margin-top: 5px;">
                    <li><strong>Click thumbnails</strong> to switch between different medals</li>
                    <li><strong>Click the medal</strong> to flip it 180¬∞ with smooth animation</li>
                    <li><strong>Drag sliders</strong> to manually rotate and control effects</li>
                    <li><strong>Animate button</strong> for continuous auto-rotation</li>
                </ul>
                <p style="margin-top: 10px;"><strong>How it works:</strong> Uses CSS 3D transforms with hardware acceleration. The browser handles all perspective and occlusion automatically using <code>preserve-3d</code>.</p>
            </div>
        </div>
    </div>
    
    <script>
        // =============================================================================
        // IMAGE LIBRARY - Add your image filenames here
        // =============================================================================
        const IMAGE_LIBRARY = [
            'Badge_conquistas_arte_da_persistencia_001.png',
            'Badge_conquistas_ativando_a_chama_001.png',
            'Badge_conquistas_bug_001.png',
            'Badge_conquistas_crescendo_com_pix_001.png',
            'Badge_conquistas_crescendo_tap_002.png',
            'Badge_conquistas_espalhando_a_semente_001.png',
            'Badge_conquistas_farol_001.png',
            'Badge_conquistas_jim_001.png',
            'Badge_conquistas_link_001.png',
            'Badge_conquistas_mestre_dos_cartoes_002.png',
            'Badge_conquistas_regador_001.png'
        ];
        
        // =============================================================================
        // SHINE EFFECT CLASS
        // =============================================================================
        class ShineEffect {
            constructor(container, gradient, imagePath) {
                this.container = container;  // .shine-container
                this.gradient = gradient;     // .shine-gradient
                this.imagePath = imagePath;
                this.lightnessMask = null;
                this.maskContrast = 1.5;
                this.shineAngle = 135;
                
                this.updateGradientAngle(this.shineAngle);
            }
            
            updateGradientAngle(angle) {
                this.shineAngle = angle;
                const gradient = `linear-gradient(${angle}deg, 
                    transparent 0%,
                    transparent 40%,
                    rgba(255,255,255,0.5) 45%,
                    rgba(255,255,255,1) 50%,
                    rgba(255,255,255,0.5) 55%,
                    transparent 60%,
                    transparent 100%)`;
                this.gradient.style.setProperty('--shine-gradient', gradient);
            }
            
            updateShinePosition(rotationAngle) {
                // Map rotation angle to transform position
                // Shine sweeps once from -60 to 60 degrees
                
                // Normalize the angle to -180 to 180 range for calculation
                let normalizedAngle = ((rotationAngle + 180) % 360) - 180;
                
                // Map -60 to 60 degree range to translateX from -150% to 150%
                // At -60deg: position = -150% (shine completely off-screen left)
                // At 0deg: position = 0% (shine in center)
                // At 60deg: position = 150% (shine completely off-screen right)
                const position = (normalizedAngle / 60) * 150;
                
                this.gradient.style.setProperty('--shine-position', `${position}%`);
            }
            
            setOpacity(opacity) {
                this.container.style.setProperty('--shine-opacity', opacity);
            }
            
            setBlur(pixels) {
                this.gradient.style.setProperty('--blur-amount', `blur(${pixels}px)`);
            }
            
            generateLightnessMask() {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        // Container is always 300x300
                        const containerSize = 300;
                        const canvas = document.createElement('canvas');
                        canvas.width = containerSize;
                        canvas.height = containerSize;
                        const ctx = canvas.getContext('2d');
                        
                        // Clear canvas with transparent background
                        ctx.clearRect(0, 0, containerSize, containerSize);
                        
                        // Calculate how the image would be displayed with background-size: contain
                        const imgAspect = img.width / img.height;
                        const containerAspect = 1; // Square container
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (imgAspect > containerAspect) {
                            // Image is wider - fit to width
                            drawWidth = containerSize;
                            drawHeight = containerSize / imgAspect;
                            drawX = 0;
                            drawY = (containerSize - drawHeight) / 2;
                        } else {
                            // Image is taller - fit to height
                            drawHeight = containerSize;
                            drawWidth = containerSize * imgAspect;
                            drawX = (containerSize - drawWidth) / 2;
                            drawY = 0;
                        }
                        
                        // Draw image centered
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        
                        try {
                            const imageData = ctx.getImageData(0, 0, containerSize, containerSize);
                            const data = imageData.data;
                            
                            for (let i = 0; i < data.length; i += 4) {
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                const alpha = data[i + 3];
                                
                                // Calculate normalized alpha (0-1)
                                const alphaNormalized = alpha / 255;
                                
                                // If pixel is transparent or very low alpha, keep it fully transparent
                                if (alpha < 128) {
                                    data[i] = 0;
                                    data[i + 1] = 0;
                                    data[i + 2] = 0;
                                    data[i + 3] = 0;
                                } else {
                                    const lightness = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
                                    const contrasty = Math.pow(lightness, this.maskContrast);
                                    const value = contrasty * 255;
                                    
                                    data[i] = value;
                                    data[i + 1] = value;
                                    data[i + 2] = value;
                                    // Use strict alpha cutoff combined with lightness for intensity
                                    data[i + 3] = alphaNormalized * contrasty * 255;
                                }
                            }
                            
                            ctx.putImageData(imageData, 0, 0);
                            this.lightnessMask = canvas.toDataURL();
                            
                            resolve(this.lightnessMask);
                        } catch (e) {
                            reject(e);
                        }
                    };
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = this.imagePath;
                });
            }
            
            applyMask() {
                if (this.lightnessMask) {
                    this.container.style.setProperty('--lightness-mask', `url(${this.lightnessMask})`);
                }
            }
            
            removeMask() {
                this.container.style.setProperty('--lightness-mask', 'none');
            }
        }
        
        // =============================================================================
        // MEDAL 3D CLASS
        // =============================================================================
        class Medal3DCSS {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                this.frontFace = this.element.querySelector('.medal-front');
                this.backFace = this.element.querySelector('.medal-back');
                this.edgeContainer = this.element.querySelector('.edge-container');
                
                this.rotation = 0;
                this.thickness = 15;
                this.animating = false;
                this.animationSpeed = 2;
                this.frontImagePath = null;
                this.edgePoints = [];
                this.imageSize = 0;
                this.edgeSegments = [];
                this.isFlipping = false;
                this.maxShineOpacity = 0.8;
                this.shineEffect = null;
                
                // Create shine elements
                this.shineContainer = document.createElement('div');
                this.shineContainer.className = 'shine-container';
                this.shineGradient = document.createElement('div');
                this.shineGradient.className = 'shine-gradient';
                this.shineContainer.appendChild(this.shineGradient);
                this.frontFace.appendChild(this.shineContainer);
                
                this.element.addEventListener('click', () => this.flip());
            }
            
            async loadMedal(imagePath, imageName) {
                this.frontImagePath = imagePath;
                
                // Preload image to ensure it's ready
                await new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => resolve();
                    img.onerror = () => reject(new Error('Failed to preload image'));
                    img.src = imagePath;
                });
                
                // Set images
                this.frontFace.style.backgroundImage = `url(${imagePath})`;
                
                // Reset state
                this.edgePoints = [];
                this.edgeSegments = [];
                
                // Initialize
                await this.extractOutline();
                this.createEdgeSegments();
                
                // Create silver back
                const silverBack = await this.createSilverVersion(imagePath);
                this.backFace.style.backgroundImage = `url(${silverBack})`;
                
                this.updateThickness();
                this.updateGradient(0, false);
                
                // Get current settings from UI controls
                const currentBlur = parseInt(document.getElementById('shineBlur').value);
                const currentAngle = parseInt(document.getElementById('shineAngle').value);
                const currentContrast = parseFloat(document.getElementById('maskContrast').value);
                
                // Remove old mask and shine effect completely
                if (this.shineEffect) {
                    this.shineEffect.removeMask();
                    this.shineEffect.setOpacity(0);
                    // Force clear all custom properties
                    this.shineGradient.style.removeProperty('--shine-gradient');
                    this.shineGradient.style.removeProperty('--shine-position');
                    this.shineGradient.style.removeProperty('--blur-amount');
                    this.shineContainer.style.removeProperty('--shine-opacity');
                    this.shineContainer.style.removeProperty('--lightness-mask');
                }
                
                // Small delay to ensure cleanup
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Create new shine effect with fresh image path
                this.shineEffect = new ShineEffect(this.shineContainer, this.shineGradient, imagePath);
                
                try {
                    // Apply current settings
                    this.shineEffect.maskContrast = currentContrast;
                    this.shineEffect.updateGradientAngle(currentAngle);
                    this.shineEffect.setBlur(currentBlur);
                    
                    // Generate and apply new mask
                    console.log('Generating mask for:', imageName);
                    await this.shineEffect.generateLightnessMask();
                    console.log('Mask generated successfully for:', imageName);
                    this.shineEffect.applyMask();
                } catch (e) {
                    console.error('Failed to create shine effect for', imageName, ':', e);
                }
                
                // setRotation will handle the initial opacity based on angle
                this.setRotation(0);
                
                // Update title
                document.getElementById('currentMedalName').textContent = imageName;
            }
            
            extractOutline() {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        this.imageSize = Math.max(img.width, img.height);
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        
                        ctx.drawImage(img, 0, 0);
                        
                        try {
                            const imageData = ctx.getImageData(0, 0, img.width, img.height);
                            const data = imageData.data;
                            
                            const centerX = img.width / 2;
                            const centerY = img.height / 2;
                            const angleSteps = 120;
                            
                            for (let i = 0; i < angleSteps; i++) {
                                const angle = (i / angleSteps) * Math.PI * 2;
                                const dx = Math.cos(angle);
                                const dy = Math.sin(angle);
                                
                                let maxRadius = 0;
                                for (let r = 0; r < Math.max(img.width, img.height) / 2; r++) {
                                    const x = Math.floor(centerX + dx * r);
                                    const y = Math.floor(centerY + dy * r);
                                    
                                    if (x >= 0 && x < img.width && y >= 0 && y < img.height) {
                                        const idx = (y * img.width + x) * 4;
                                        const alpha = data[idx + 3];
                                        if (alpha > 128) {
                                            maxRadius = r;
                                        }
                                    }
                                }
                                
                                this.edgePoints.push({
                                    angle: angle,
                                    radius: maxRadius,
                                    x: dx * maxRadius,
                                    y: dy * maxRadius
                                });
                            }
                            
                            console.log(`Extracted ${this.edgePoints.length} edge points`);
                        } catch (e) {
                            console.error('Failed to extract outline:', e);
                            this.createCircularOutline();
                        }
                        
                        resolve();
                    };
                    img.onerror = () => {
                        console.error('Failed to load image');
                        this.createCircularOutline();
                        resolve();
                    };
                    img.src = this.frontImagePath;
                });
            }
            
            createCircularOutline() {
                this.imageSize = 300;
                const angleSteps = 120;
                const radius = 150;
                for (let i = 0; i < angleSteps; i++) {
                    const angle = (i / angleSteps) * Math.PI * 2;
                    this.edgePoints.push({
                        angle: angle,
                        radius: radius,
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
            }
            
            createEdgeSegments() {
                this.edgeContainer.innerHTML = '';
                this.edgeSegments = [];
                
                const containerSize = 300;
                const scaleFactor = containerSize / this.imageSize;
                
                for (let i = 0; i < this.edgePoints.length; i++) {
                    const currentPoint = this.edgePoints[i];
                    const nextPoint = this.edgePoints[(i + 1) % this.edgePoints.length];
                    
                    const x1 = currentPoint.x * scaleFactor;
                    const y1 = currentPoint.y * scaleFactor;
                    const x2 = nextPoint.x * scaleFactor;
                    const y2 = nextPoint.y * scaleFactor;
                    
                    const width = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) + 1.5;
                    
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    
                    const tangentAngle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
                    
                    const segment = document.createElement('div');
                    segment.className = 'edge-segment';
                    segment.style.width = `${width}px`;
                    segment.style.height = `${this.thickness}px`;
                    
                    segment.style.transformOrigin = '50% 50%';
                    
                    const baseTransform = `translate(-50%, -50%) translate(${midX}px, ${midY}px) rotateZ(${tangentAngle}deg) rotateX(90deg) translateZ(0px)`;
                    
                    segment.setAttribute('data-base-transform', baseTransform);
                    segment.style.transform = baseTransform;
                    
                    this.edgeContainer.appendChild(segment);
                    this.edgeSegments.push(segment);
                }
                
                console.log(`Created ${this.edgeSegments.length} edge segments`);
            }
            
            updateThickness() {
                const halfThickness = this.thickness / 2;
                
                this.frontFace.style.transform = `translateZ(${halfThickness}px)`;
                this.backFace.style.transform = `translateZ(-${halfThickness}px) rotateY(180deg)`;
                
                this.edgeSegments.forEach(segment => {
                    segment.style.height = `${this.thickness}px`;
                });
            }
            
            setRotation(angle) {
                this.rotation = angle;
                this.element.style.transform = `rotateY(${angle}deg)`;
                
                const normalizedAngle = ((angle % 360) + 360) % 360;
                const needsFlip = normalizedAngle > 90 && normalizedAngle < 270;
                
                if (needsFlip) {
                    this.edgeContainer.style.transform = 'rotateY(180deg)';
                } else {
                    this.edgeContainer.style.transform = '';
                }
                
                this.updateGradient(angle, needsFlip);
                
                if (this.shineEffect) {
                    this.shineEffect.updateShinePosition(normalizedAngle);
                    
                    let opacity = 0;
                    if (normalizedAngle <= 90) {
                        opacity = this.maxShineOpacity;
                    } else if (normalizedAngle >= 270) {
                        opacity = this.maxShineOpacity;
                    }
                    console.log('Setting shine opacity to:', opacity, 'at angle:', normalizedAngle);
                    this.shineEffect.setOpacity(opacity);
                }
            }
            
            updateGradient(rotationAngle, needsFlip) {
                const lightOffset = (rotationAngle / 360) * Math.PI * 2;
                const flipOffset = needsFlip ? Math.PI : 0;
                
                this.edgeSegments.forEach((segment, index) => {
                    const segmentAngle = (index / this.edgeSegments.length) * Math.PI * 2;
                    const lightAngle = segmentAngle + lightOffset + flipOffset;
                    
                    const mainReflection = Math.pow(Math.sin(lightAngle) * 0.5 + 0.5, 1.5);
                    const detailReflection = Math.sin(lightAngle * 5) * 0.25;
                    const highlight = Math.pow(Math.max(0, Math.sin(lightAngle)), 32) * 0.5;
                    
                    const reflectionValue = mainReflection + detailReflection + highlight;
                    const lightness = 25 + (reflectionValue * 75);
                    
                    segment.style.backgroundColor = `hsl(0, 0%, ${lightness}%)`;
                });
            }
            
            setThickness(thickness) {
                this.thickness = thickness;
                this.updateThickness();
            }
            
            animate() {
                if (!this.animating) return;
                
                this.rotation += this.animationSpeed;
                this.setRotation(this.rotation);
                
                const displayRotation = ((this.rotation + 180) % 360) - 180;
                document.getElementById('rotation').value = displayRotation;
                document.getElementById('rotationValue').textContent = Math.round(this.rotation);
                
                requestAnimationFrame(() => this.animate());
            }
            
            startAnimation() {
                this.animating = true;
                this.animate();
            }
            
            stopAnimation() {
                this.animating = false;
            }
            
            reset() {
                this.rotation = 0;
                this.setRotation(0);
                document.getElementById('rotation').value = 0;
                document.getElementById('rotationValue').textContent = 0;
            }
            
            flip() {
                if (this.isFlipping) return;
                
                this.isFlipping = true;
                this.element.classList.add('flipping');
                
                const targetRotation = this.rotation + 180;
                const startRotation = this.rotation;
                const startTime = performance.now();
                const duration = 1200;
                
                const animateFlip = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    const eased = progress === 1 ? 1 : 1 - Math.pow(2, -10 * progress);
                    
                    const currentRotation = startRotation + (180 * eased);
                    this.setRotation(currentRotation);
                    
                    const displayRotation = ((currentRotation + 180) % 360) - 180;
                    document.getElementById('rotation').value = displayRotation;
                    document.getElementById('rotationValue').textContent = Math.round(currentRotation);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateFlip);
                    } else {
                        this.rotation = targetRotation;
                        this.element.classList.remove('flipping');
                        this.isFlipping = false;
                    }
                };
                
                requestAnimationFrame(animateFlip);
            }
            
            createSilverVersion(imagePath) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.drawImage(img, 0, 0);
                        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        for (let i = 0; i < data.length; i += 4) {
                            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                            data[i] = Math.min(255, gray * 0.95 + 20);
                            data[i + 1] = Math.min(255, gray * 0.97 + 20);
                            data[i + 2] = Math.min(255, gray + 25);
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                        resolve(canvas.toDataURL());
                    };
                    img.src = imagePath;
                });
            }
        }
        
        // =============================================================================
        // LIBRARY MANAGER
        // =============================================================================
        class MedalLibrary {
            constructor() {
                this.medal = new Medal3DCSS('medal');
                this.currentImageIndex = -1;
                this.thumbnailGrid = document.getElementById('thumbnailGrid');
                this.loadingOverlay = document.getElementById('loadingOverlay');
                
                this.init();
            }
            
            async init() {
                this.createThumbnails();
                document.getElementById('imageCount').textContent = `(${IMAGE_LIBRARY.length} medals)`;
                
                // Load first medal
                await this.loadMedal(0);
            }
            
            createThumbnails() {
                this.thumbnailGrid.innerHTML = '';
                
                IMAGE_LIBRARY.forEach((filename, index) => {
                    const thumbnail = document.createElement('div');
                    thumbnail.className = 'thumbnail';
                    if (index === this.currentImageIndex) {
                        thumbnail.classList.add('active');
                    }
                    
                    const img = document.createElement('img');
                    img.src = `images/${filename}`;
                    img.alt = filename;
                    
                    const name = document.createElement('div');
                    name.className = 'thumbnail-name';
                    name.textContent = this.formatName(filename);
                    
                    thumbnail.appendChild(img);
                    thumbnail.appendChild(name);
                    
                    thumbnail.addEventListener('click', () => this.loadMedal(index));
                    
                    this.thumbnailGrid.appendChild(thumbnail);
                });
            }
            
            formatName(filename) {
                // Remove extension and replace underscores with spaces
                return filename
                    .replace(/\.[^/.]+$/, '')
                    .replace(/_/g, ' ')
                    .replace(/Badge conquistas /i, '')
                    .trim();
            }
            
            async loadMedal(index) {
                if (index === this.currentImageIndex) return;
                
                this.currentImageIndex = index;
                const filename = IMAGE_LIBRARY[index];
                const imagePath = `images/${filename}`;
                
                // Show loading
                this.loadingOverlay.classList.add('active');
                
                // Stop any animation
                this.medal.stopAnimation();
                
                // Update active thumbnail
                document.querySelectorAll('.thumbnail').forEach((thumb, i) => {
                    thumb.classList.toggle('active', i === index);
                });
                
                try {
                    await this.medal.loadMedal(imagePath, this.formatName(filename));
                } catch (e) {
                    console.error('Failed to load medal:', e);
                    document.getElementById('currentMedalName').textContent = 'Error loading medal';
                }
                
                // Hide loading
                this.loadingOverlay.classList.remove('active');
            }
        }
        
        // =============================================================================
        // INITIALIZE
        // =============================================================================
        let library;
        
        window.addEventListener('load', async () => {
            library = new MedalLibrary();
            
            // Controls
            document.getElementById('rotation').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('rotationValue').textContent = Math.round(value);
                library.medal.setRotation(value);
            });
            
            document.getElementById('thickness').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('thicknessValue').textContent = value;
                library.medal.setThickness(value);
            });
            
            document.getElementById('speed').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = value.toFixed(1);
                library.medal.animationSpeed = value;
            });
            
            document.getElementById('animate').addEventListener('click', () => {
                library.medal.startAnimation();
            });
            
            document.getElementById('stop').addEventListener('click', () => {
                library.medal.stopAnimation();
            });
            
            document.getElementById('reset').addEventListener('click', () => {
                library.medal.stopAnimation();
                library.medal.reset();
            });
            
            // Shine Effect Controls
            document.getElementById('shineAngle').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('shineAngleValue').textContent = value;
                if (library.medal.shineEffect) {
                    library.medal.shineEffect.updateGradientAngle(value);
                }
            });
            
            document.getElementById('shineBlur').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('shineBlurValue').textContent = value;
                if (library.medal.shineEffect) {
                    library.medal.shineEffect.setBlur(value);
                }
            });
            
            document.getElementById('maskContrast').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('maskContrastValue').textContent = value.toFixed(1);
                if (library.medal.shineEffect) {
                    library.medal.shineEffect.maskContrast = value;
                }
            });
            
            document.getElementById('shineOpacity').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('shineOpacityValue').textContent = value.toFixed(2);
                library.medal.maxShineOpacity = value;
                library.medal.setRotation(library.medal.rotation);
            });
            
            document.getElementById('regenerateMask').addEventListener('click', async () => {
                if (!library.medal.shineEffect) return;
                
                const btn = document.getElementById('regenerateMask');
                btn.disabled = true;
                btn.textContent = '‚è≥ Regenerating...';
                
                try {
                    await library.medal.shineEffect.generateLightnessMask();
                    library.medal.shineEffect.applyMask();
                    
                    btn.textContent = '‚úì Mask Regenerated!';
                    setTimeout(() => {
                        btn.textContent = 'üîÑ Regenerate Shine Mask';
                        btn.disabled = false;
                    }, 2000);
                } catch (e) {
                    console.error('Failed to regenerate mask:', e);
                    btn.textContent = '‚ùå Error - Try Again';
                    btn.disabled = false;
                }
            });
        });
    </script>
</body>
</html>
