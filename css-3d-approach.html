<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Medal Library - CSS Transform Approach</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #f5f5f0; /* Off-white */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #333;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        body.dark-mode {
            background: #2a2a2a; /* Dark grey */
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            flex: 1;
            min-width: 200px;
        }
        
        .subtitle {
            text-align: center;
            opacity: 0.8;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .title-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .medal-title-with-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .medal-title-text {
            font-size: 20px;
            font-weight: bold;
            min-height: 28px;
        }
        
        .top-button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .top-button-group button {
            padding: 8px 16px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.1);
            color: inherit;
            transition: all 0.2s ease;
        }
        
        body.dark-mode .top-button-group button {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .top-button-group button:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }
        
        body.dark-mode .top-button-group button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .dark-mode-toggle {
            padding: 8px 16px;
            font-size: 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: rgba(0, 0, 0, 0.1);
            color: inherit;
            transition: all 0.2s ease;
        }
        
        body.dark-mode .dark-mode-toggle {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .dark-mode-toggle:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: translateY(-1px);
        }
        
        body.dark-mode .dark-mode-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        /* Main Medal Display */
        .medal-display {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        body.dark-mode .medal-display {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .medal-title {
            text-align: center;
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: bold;
            min-height: 28px;
        }
        
        .scene {
            width: 100%;
            height: 400px;
            perspective: 1000px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            border-radius: 15px;
            z-index: 10;
            flex-direction: column;
            gap: 15px;
        }
        
        .loading-overlay.active {
            display: flex;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 16px;
            opacity: 0.9;
        }
        
        .medal-3d {
            width: 300px;
            height: 300px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.05s linear;
            cursor: pointer;
        }
        
        .medal-3d.hover-rotate {
            transition: transform 0.2s ease-out;
        }
        
        .medal-3d.flipping {
            transition: transform 1.2s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        .medal-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            overflow: hidden;
        }
        
        /* Shine container with mask - stationary */
        .shine-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
            z-index: 10;
            -webkit-mask-image: var(--lightness-mask, none);
            mask-image: var(--lightness-mask, none);
            -webkit-mask-size: 100% 100%;
            mask-size: 100% 100%;
            -webkit-mask-position: 0 0;
            mask-position: 0 0;
            -webkit-mask-repeat: no-repeat;
            mask-repeat: no-repeat;
            opacity: var(--shine-opacity, 0);
        }
        
        /* Shine gradient - moving inside container */
        .shine-gradient {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--shine-gradient, linear-gradient(135deg, 
                transparent 0%,
                transparent 45%,
                rgba(255,255,255,0.8) 48%,
                rgba(255,255,255,1) 50%,
                rgba(255,255,255,0.8) 52%,
                transparent 55%,
                transparent 100%));
            background-size: 400% 400%;
            background-position: var(--shine-position, 0% 0%);
            filter: var(--blur-amount, blur(15px));
            will-change: background-position;
        }
        
        .medal-front {
            transform: translateZ(15px);
        }
        
        .medal-back {
            transform: translateZ(-15px) rotateY(180deg);
        }
        
        .medal-edge {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.1s linear;
        }
        
        .edge-container {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            pointer-events: none;
        }
        
        .edge-segment {
            position: absolute;
            left: 50%;
            top: 50%;
            transform-style: preserve-3d;
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.3), 
                        inset 0 -1px 1px rgba(0,0,0,0.3);
        }
        
        /* Thumbnail Library */
        .library-section {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        body.dark-mode .library-section {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .library-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .thumbnail-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .thumbnail {
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid transparent;
            overflow: hidden;
            position: relative;
        }
        
        body.dark-mode .thumbnail {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .thumbnail:hover {
            transform: translateY(-3px);
            background: rgba(0, 0, 0, 0.2);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        body.dark-mode .thumbnail:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .thumbnail.active {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }
        
        .thumbnail img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            padding: 10px;
        }
        
        .thumbnail-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px;
            font-size: 10px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .thumbnail:hover .thumbnail-name {
            opacity: 1;
        }
        
        /* Controls */
        .controls {
            background: rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        body.dark-mode .controls {
            background: rgba(0, 0, 0, 0.3);
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.2);
            outline: none;
            -webkit-appearance: none;
        }
        
        body.dark-mode input[type="range"] {
            background: rgba(255, 255, 255, 0.2);
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .value-display {
            min-width: 60px;
            text-align: right;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        button {
            background: rgba(0, 0, 0, 0.2);
            color: inherit;
            border: 1px solid rgba(0, 0, 0, 0.2);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, background 0.2s;
            margin-right: 10px;
        }
        
        body.dark-mode button {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            background: rgba(0, 0, 0, 0.3);
        }
        
        body.dark-mode button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .info-box {
            background: rgba(0, 0, 0, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        body.dark-mode .info-box {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .info-box h3 {
            margin-bottom: 10px;
            color: #ffd700;
        }
        
        hr {
            margin: 25px 0;
            border: none;
            border-top: 1px solid rgba(0, 0, 0, 0.2);
        }
        
        body.dark-mode hr {
            border-top-color: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-controls">
            <h1>üèÖ 3D Medal Library</h1>
            <button class="dark-mode-toggle" id="darkModeToggle">üåô Dark Mode</button>
        </div>
        <p class="subtitle">Click any thumbnail to load a different medal</p>
        
        <!-- Main Medal Display -->
        <div class="medal-display">
            <div class="medal-title-with-controls">
                <div class="medal-title-text" id="currentMedalName">Loading...</div>
                <div class="top-button-group">
                    <button id="animate">‚ñ∂ Animate</button>
                    <button id="stop">‚è∏ Stop</button>
                    <button id="reset">‚Ü∫ Reset</button>
                </div>
            </div>
            <div class="scene">
                <div class="loading-overlay" id="loadingOverlay">
                    <div class="spinner"></div>
                    <div class="loading-text">Generating 3D medal...</div>
                </div>
                <div class="medal-3d" id="medal">
                    <div class="medal-front medal-face"></div>
                    <div class="edge-container"></div>
                    <div class="medal-back medal-face"></div>
                </div>
            </div>
        </div>
        
        <!-- Thumbnail Library -->
        <div class="library-section">
            <div class="library-title">
                üìö Medal Library
                <span style="opacity: 0.7; font-size: 14px; font-weight: normal;" id="imageCount"></span>
            </div>
            <div class="thumbnail-grid" id="thumbnailGrid">
                <!-- Thumbnails will be dynamically inserted here -->
            </div>
        </div>
        
        <!-- Controls -->
        <div class="controls">
            <div class="control-group">
                <label>Rotation Angle (Y-axis)</label>
                <div class="control-row">
                    <input type="range" id="rotation" min="-180" max="180" value="0" step="1">
                    <span class="value-display"><span id="rotationValue">0</span>¬∞</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Medal Thickness</label>
                <div class="control-row">
                    <input type="range" id="thickness" min="5" max="50" value="15" step="1">
                    <span class="value-display"><span id="thicknessValue">15</span>px</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Animation Speed</label>
                <div class="control-row">
                    <input type="range" id="speed" min="0.5" max="5" value="0.5" step="0.1">
                    <span class="value-display"><span id="speedValue">0.5</span>x</span>
                </div>
            </div>
            
            <hr>
            
            <h3 style="margin-bottom: 15px; color: #ffd700;">‚ú® Shine Effect Controls</h3>
            
            <div class="control-group">
                <label>Shine Angle (gradient direction)</label>
                <div class="control-row">
                    <input type="range" id="shineAngle" min="0" max="360" value="135" step="1">
                    <span class="value-display"><span id="shineAngleValue">135</span>¬∞</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Blur Amount</label>
                <div class="control-row">
                    <input type="range" id="shineBlur" min="0" max="50" value="15" step="1">
                    <span class="value-display"><span id="shineBlurValue">15</span>px</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Mask Contrast Power</label>
                <div class="control-row">
                    <input type="range" id="maskContrast" min="0.5" max="5" value="0.5" step="0.1">
                    <span class="value-display"><span id="maskContrastValue">0.5</span></span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Max Shine Opacity</label>
                <div class="control-row">
                    <input type="range" id="shineOpacity" min="0" max="1" value="0.8" step="0.05">
                    <span class="value-display"><span id="shineOpacityValue">0.80</span></span>
                </div>
            </div>
            
            <div class="control-group">
                <div class="button-group">
                    <button id="regenerateMask">üîÑ Regenerate Shine Mask</button>
                </div>
            </div>
            
            <div class="info-box">
                <h3>‚ú® How to Use</h3>
                <ul style="margin-left: 20px; margin-top: 5px;">
                    <li><strong>Click thumbnails</strong> to switch between different medals</li>
                    <li><strong>Click the medal</strong> to flip it 180¬∞ with smooth animation</li>
                    <li><strong>Drag sliders</strong> to manually rotate and control effects</li>
                    <li><strong>Animate button</strong> for continuous auto-rotation</li>
                </ul>
                <p style="margin-top: 10px;"><strong>How it works:</strong> Uses CSS 3D transforms with hardware acceleration. The browser handles all perspective and occlusion automatically using <code>preserve-3d</code>.</p>
            </div>
        </div>
    </div>
    
    <script>
        // =============================================================================
        // IMAGE LIBRARY - Add your image filenames here
        // =============================================================================
        const IMAGE_LIBRARY = [
            'Badge_conquistas_arte_da_persistencia_001.png',
            'Badge_conquistas_ativando_a_chama_001.png',
            'Badge_conquistas_bug_001.png',
            'Badge_conquistas_crescendo_com_pix_001.png',
            'Badge_conquistas_crescendo_tap_002.png',
            'Badge_conquistas_espalhando_a_semente_001.png',
            'Badge_conquistas_farol_001.png',
            'Badge_conquistas_jim_001.png',
            'Badge_conquistas_link_001.png',
            'Badge_conquistas_mestre_dos_cartoes_002.png',
            'Badge_conquistas_regador_001.png'
        ];
        
        // =============================================================================
        // SHINE EFFECT CLASS
        // =============================================================================
        class ShineEffect {
            constructor(container, gradient, imagePath) {
                this.container = container;  // .shine-container
                this.gradient = gradient;     // .shine-gradient
                this.imagePath = imagePath;
                this.lightnessMask = null;
                this.maskContrast = 0.5;
                this.shineAngle = 135;
                this.previousNormalizedAngle = null; // Track previous angle for smooth wraparound
                this.unwrappedAngle = null; // Track unwrapped angle for continuous movement
                this.smoothedUnwrappedAngle = null; // Smoothed version of unwrapped angle
                this.currentBgPosition = null; // Current smoothed position
                this.targetBgPosition = null; // Target position to lerp towards
                this.lastUpdateTime = null; // For time-based smoothing
                
                this.updateGradientAngle(this.shineAngle);
            }
            
            updateGradientAngle(angle) {
                this.shineAngle = angle;
                const gradient = `linear-gradient(${angle}deg, 
                    transparent 0%,
                    transparent 40%,
                    rgba(255,255,255,0.5) 45%,
                    rgba(255,255,255,1) 50%,
                    rgba(255,255,255,0.5) 55%,
                    transparent 60%,
                    transparent 100%)`;
                this.gradient.style.setProperty('--shine-gradient', gradient);
            }
            
            updateShinePosition(rotationAngle, isFlipping = false) {
                // Map rotation angle to background position
                // Shine sweeps twice: from -90 to 0, then from 0 to 90
                // At 0 degrees, shine is offset off-screen
                //
                // Background is 400% size, so we can position the stripe anywhere
                // Background-position controls where the stripe appears
                
                // Normalize the angle to -180 to 180 range for calculation
                let normalizedAngle = ((rotationAngle + 180) % 360) - 180;
                
                // Handle edge case: 180 should be treated as -180 for consistency
                if (normalizedAngle === 180) {
                    normalizedAngle = -180;
                }
                
                // Unwrap the angle to handle continuous rotation smoothly
                // This prevents jumps when crossing the -180/180 boundary
                if (this.unwrappedAngle === null) {
                    this.unwrappedAngle = normalizedAngle;
                    this.smoothedUnwrappedAngle = normalizedAngle;
                } else {
                    // Calculate the shortest path from previous unwrapped angle to new normalized angle
                    // First, normalize the unwrapped angle to -180 to 180 range for comparison
                    let prevNormalized = ((this.unwrappedAngle + 180) % 360) - 180;
                    if (prevNormalized === 180) prevNormalized = -180;
                    
                    // Calculate delta between normalized angles
                    let delta = normalizedAngle - prevNormalized;
                    
                    // If the delta is more than 180 degrees, we wrapped around
                    if (delta > 180) {
                        delta -= 360;
                    } else if (delta < -180) {
                        delta += 360;
                    }
                    
                    // Update unwrapped angle by the delta
                    this.unwrappedAngle += delta;
                    
                    // Smooth the unwrapped angle to slow down shine movement relative to rotation
                    // This prevents the shine from moving too fast during rapid rotations
                    const now = performance.now();
                    if (this.lastUpdateTime === null) {
                        this.lastUpdateTime = now;
                    }
                    const deltaTime = (now - this.lastUpdateTime) / 1000;
                    this.lastUpdateTime = now;
                    
                    // Smooth the angle change - use slower smoothing during flips
                    // Lower factor = slower movement relative to rotation
                    // During flips, use much slower smoothing (0.2) vs normal (0.5)
                    const smoothingBase = isFlipping ? 0.2 : 0.5;
                    const angleSmoothingFactor = 1 - Math.pow(smoothingBase, deltaTime * 60);
                    const angleDelta = this.unwrappedAngle - this.smoothedUnwrappedAngle;
                    this.smoothedUnwrappedAngle += angleDelta * angleSmoothingFactor;
                }
                
                // Map the smoothed unwrapped angle to position
                // The shine sweeps from -90¬∞ to 90¬∞ (180¬∞ range)
                // We use modulo to wrap the angle into this range continuously
                let angleForPosition = this.smoothedUnwrappedAngle;
                
                // Wrap angle into -90 to 90 range continuously using modulo
                // This creates smooth, continuous movement even during rapid rotations
                // Shift to 0-180 range, apply modulo, then shift back
                angleForPosition = ((angleForPosition + 90) % 180);
                if (angleForPosition < 0) angleForPosition += 180;
                angleForPosition -= 90;
                
                let bgPosition;
                
                if (angleForPosition >= -90 && angleForPosition <= 0) {
                    // First pass: -90¬∞ to 0¬∞
                    // Map -90¬∞ to 0¬∞ range to background-position from 0% to 25%
                    bgPosition = ((angleForPosition + 90) / 90) * 25;
                } else if (angleForPosition > 0 && angleForPosition <= 90) {
                    // Second pass: 0¬∞ to 90¬∞
                    // Map 0¬∞ to 90¬∞ range to background-position from 25% to 100%
                    bgPosition = 25 + (angleForPosition / 90) * 75;
                } else {
                    // Should never reach here, but safety check
                    bgPosition = angleForPosition < -90 ? 0 : 100;
                }
                
                // Use the calculated position directly (no additional smoothing needed since we smoothed the angle)
                this.previousNormalizedAngle = normalizedAngle;
                this.gradient.style.setProperty('--shine-position', `${bgPosition}% ${bgPosition}%`);
            }
            
            setOpacity(opacity) {
                this.container.style.setProperty('--shine-opacity', opacity);
            }
            
            setBlur(pixels) {
                this.gradient.style.setProperty('--blur-amount', `blur(${pixels}px)`);
            }
            
            generateLightnessMask() {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        // Container is always 300x300
                        const containerSize = 300;
                        const canvas = document.createElement('canvas');
                        canvas.width = containerSize;
                        canvas.height = containerSize;
                        const ctx = canvas.getContext('2d');
                        
                        // Clear canvas with transparent background
                        ctx.clearRect(0, 0, containerSize, containerSize);
                        
                        // Calculate how the image would be displayed with background-size: contain
                        const imgAspect = img.width / img.height;
                        const containerAspect = 1; // Square container
                        
                        let drawWidth, drawHeight, drawX, drawY;
                        
                        if (imgAspect > containerAspect) {
                            // Image is wider - fit to width
                            drawWidth = containerSize;
                            drawHeight = containerSize / imgAspect;
                            drawX = 0;
                            drawY = (containerSize - drawHeight) / 2;
                        } else {
                            // Image is taller - fit to height
                            drawHeight = containerSize;
                            drawWidth = containerSize * imgAspect;
                            drawX = (containerSize - drawWidth) / 2;
                            drawY = 0;
                        }
                        
                        // Draw image centered
                        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
                        
                        try {
                            const imageData = ctx.getImageData(0, 0, containerSize, containerSize);
                            const data = imageData.data;
                            
                            for (let i = 0; i < data.length; i += 4) {
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                const alpha = data[i + 3];
                                
                                // Calculate normalized alpha (0-1)
                                const alphaNormalized = alpha / 255;
                                
                                // If pixel is transparent or very low alpha, keep it fully transparent
                                if (alpha < 128) {
                                    data[i] = 0;
                                    data[i + 1] = 0;
                                    data[i + 2] = 0;
                                    data[i + 3] = 0;
                                } else {
                                    const lightness = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
                                    const contrasty = Math.pow(lightness, this.maskContrast);
                                    const value = contrasty * 255;
                                    
                                    data[i] = value;
                                    data[i + 1] = value;
                                    data[i + 2] = value;
                                    // Use strict alpha cutoff combined with lightness for intensity
                                    data[i + 3] = alphaNormalized * contrasty * 255;
                                }
                            }
                            
                            ctx.putImageData(imageData, 0, 0);
                            this.lightnessMask = canvas.toDataURL();
                            
                            resolve(this.lightnessMask);
                        } catch (e) {
                            reject(e);
                        }
                    };
                    img.onerror = () => reject(new Error('Failed to load image'));
                    img.src = this.imagePath;
                });
            }
            
            applyMask() {
                if (this.lightnessMask) {
                    this.container.style.setProperty('--lightness-mask', `url(${this.lightnessMask})`);
                }
            }
            
            removeMask() {
                this.container.style.setProperty('--lightness-mask', 'none');
            }
        }
        
        // =============================================================================
        // MEDAL 3D CLASS
        // =============================================================================
        class Medal3DCSS {
            constructor(elementId) {
                this.element = document.getElementById(elementId);
                this.frontFace = this.element.querySelector('.medal-front');
                this.backFace = this.element.querySelector('.medal-back');
                this.edgeContainer = this.element.querySelector('.edge-container');
                
                this.rotation = 0;
                this.thickness = 15;
                this.animating = false;
                this.animationSpeed = 0.5;
                this.frontImagePath = null;
                this.edgePoints = [];
                this.imageSize = 0;
                this.edgeSegments = [];
                this.isFlipping = false;
                this.maxShineOpacity = 0.8;
                this.isPageHovered = false; // Track if page is being hovered
                this.hoverRotationDisabled = false; // Track if hover rotation is temporarily disabled
                this.shineEffectFront = null;
                this.shineEffectBack = null;
                
                // Create shine elements for front face
                this.shineContainerFront = document.createElement('div');
                this.shineContainerFront.className = 'shine-container';
                this.shineGradientFront = document.createElement('div');
                this.shineGradientFront.className = 'shine-gradient';
                this.shineContainerFront.appendChild(this.shineGradientFront);
                this.frontFace.appendChild(this.shineContainerFront);
                
                // Create shine elements for back face
                this.shineContainerBack = document.createElement('div');
                this.shineContainerBack.className = 'shine-container';
                this.shineGradientBack = document.createElement('div');
                this.shineGradientBack.className = 'shine-gradient';
                this.shineContainerBack.appendChild(this.shineGradientBack);
                this.backFace.appendChild(this.shineContainerBack);
                
                this.element.addEventListener('click', () => this.flip());
            }
            
            async loadMedal(imagePath, imageName) {
                this.frontImagePath = imagePath;
                
                // Preload image to ensure it's ready
                await new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => resolve();
                    img.onerror = () => reject(new Error('Failed to preload image'));
                    img.src = imagePath;
                });
                
                // Set images
                this.frontFace.style.backgroundImage = `url(${imagePath})`;
                
                // Reset state
                this.edgePoints = [];
                this.edgeSegments = [];
                
                // Initialize
                await this.extractOutline();
                this.createEdgeSegments();
                
                // Create silver back
                const silverBack = await this.createSilverVersion(imagePath);
                this.backFace.style.backgroundImage = `url(${silverBack})`;
                
                this.updateThickness();
                this.updateGradient(0, false);
                
                // Get current settings from UI controls
                const currentBlur = parseInt(document.getElementById('shineBlur').value);
                const currentAngle = parseInt(document.getElementById('shineAngle').value);
                const currentContrast = parseFloat(document.getElementById('maskContrast').value);
                
                // Remove old mask and shine effects completely
                if (this.shineEffectFront) {
                    this.shineEffectFront.removeMask();
                    this.shineEffectFront.setOpacity(0);
                    this.shineGradientFront.style.removeProperty('--shine-gradient');
                    this.shineGradientFront.style.removeProperty('--shine-position');
                    this.shineGradientFront.style.removeProperty('--blur-amount');
                    this.shineContainerFront.style.removeProperty('--shine-opacity');
                    this.shineContainerFront.style.removeProperty('--lightness-mask');
                }
                if (this.shineEffectBack) {
                    this.shineEffectBack.removeMask();
                    this.shineEffectBack.setOpacity(0);
                    this.shineGradientBack.style.removeProperty('--shine-gradient');
                    this.shineGradientBack.style.removeProperty('--shine-position');
                    this.shineGradientBack.style.removeProperty('--blur-amount');
                    this.shineContainerBack.style.removeProperty('--shine-opacity');
                    this.shineContainerBack.style.removeProperty('--lightness-mask');
                }
                
                // Small delay to ensure cleanup
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Create new shine effects for both front and back
                this.shineEffectFront = new ShineEffect(this.shineContainerFront, this.shineGradientFront, imagePath);
                this.shineEffectBack = new ShineEffect(this.shineContainerBack, this.shineGradientBack, imagePath);
                
                try {
                    // Apply current settings to both
                    this.shineEffectFront.maskContrast = currentContrast;
                    this.shineEffectFront.updateGradientAngle(currentAngle);
                    this.shineEffectFront.setBlur(currentBlur);
                    
                    this.shineEffectBack.maskContrast = currentContrast;
                    this.shineEffectBack.updateGradientAngle(currentAngle);
                    this.shineEffectBack.setBlur(currentBlur);
                    
                    // Generate and apply masks for both
                    console.log('Generating masks for:', imageName);
                    await Promise.all([
                        this.shineEffectFront.generateLightnessMask(),
                        this.shineEffectBack.generateLightnessMask()
                    ]);
                    console.log('Masks generated successfully for:', imageName);
                    this.shineEffectFront.applyMask();
                    this.shineEffectBack.applyMask();
                } catch (e) {
                    console.error('Failed to create shine effects for', imageName, ':', e);
                }
                
                // setRotation will handle the initial opacity based on angle
                this.setRotation(0);
                
                // Update title
                document.getElementById('currentMedalName').textContent = imageName;
            }
            
            extractOutline() {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        this.imageSize = Math.max(img.width, img.height);
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });
                        
                        ctx.drawImage(img, 0, 0);
                        
                        try {
                            const imageData = ctx.getImageData(0, 0, img.width, img.height);
                            const data = imageData.data;
                            
                            const centerX = img.width / 2;
                            const centerY = img.height / 2;
                            const angleSteps = 120;
                            
                            for (let i = 0; i < angleSteps; i++) {
                                const angle = (i / angleSteps) * Math.PI * 2;
                                const dx = Math.cos(angle);
                                const dy = Math.sin(angle);
                                
                                let maxRadius = 0;
                                for (let r = 0; r < Math.max(img.width, img.height) / 2; r++) {
                                    const x = Math.floor(centerX + dx * r);
                                    const y = Math.floor(centerY + dy * r);
                                    
                                    if (x >= 0 && x < img.width && y >= 0 && y < img.height) {
                                        const idx = (y * img.width + x) * 4;
                                        const alpha = data[idx + 3];
                                        if (alpha > 128) {
                                            maxRadius = r;
                                        }
                                    }
                                }
                                
                                this.edgePoints.push({
                                    angle: angle,
                                    radius: maxRadius,
                                    x: dx * maxRadius,
                                    y: dy * maxRadius
                                });
                            }
                            
                            console.log(`Extracted ${this.edgePoints.length} edge points`);
                        } catch (e) {
                            console.error('Failed to extract outline:', e);
                            this.createCircularOutline();
                        }
                        
                        resolve();
                    };
                    img.onerror = () => {
                        console.error('Failed to load image');
                        this.createCircularOutline();
                        resolve();
                    };
                    img.src = this.frontImagePath;
                });
            }
            
            createCircularOutline() {
                this.imageSize = 300;
                const angleSteps = 120;
                const radius = 150;
                for (let i = 0; i < angleSteps; i++) {
                    const angle = (i / angleSteps) * Math.PI * 2;
                    this.edgePoints.push({
                        angle: angle,
                        radius: radius,
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius
                    });
                }
            }
            
            createEdgeSegments() {
                this.edgeContainer.innerHTML = '';
                this.edgeSegments = [];
                
                const containerSize = 300;
                const scaleFactor = containerSize / this.imageSize;
                
                for (let i = 0; i < this.edgePoints.length; i++) {
                    const currentPoint = this.edgePoints[i];
                    const nextPoint = this.edgePoints[(i + 1) % this.edgePoints.length];
                    
                    const x1 = currentPoint.x * scaleFactor;
                    const y1 = currentPoint.y * scaleFactor;
                    const x2 = nextPoint.x * scaleFactor;
                    const y2 = nextPoint.y * scaleFactor;
                    
                    const width = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) + 1.5;
                    
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    
                    const tangentAngle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
                    
                    const segment = document.createElement('div');
                    segment.className = 'edge-segment';
                    segment.style.width = `${width}px`;
                    segment.style.height = `${this.thickness}px`;
                    
                    segment.style.transformOrigin = '50% 50%';
                    
                    const baseTransform = `translate(-50%, -50%) translate(${midX}px, ${midY}px) rotateZ(${tangentAngle}deg) rotateX(90deg) translateZ(0px)`;
                    
                    segment.setAttribute('data-base-transform', baseTransform);
                    segment.style.transform = baseTransform;
                    
                    this.edgeContainer.appendChild(segment);
                    this.edgeSegments.push(segment);
                }
                
                console.log(`Created ${this.edgeSegments.length} edge segments`);
            }
            
            updateThickness() {
                const halfThickness = this.thickness / 2;
                
                this.frontFace.style.transform = `translateZ(${halfThickness}px)`;
                this.backFace.style.transform = `translateZ(-${halfThickness}px) rotateY(180deg)`;
                
                this.edgeSegments.forEach(segment => {
                    segment.style.height = `${this.thickness}px`;
                });
            }
            
            setRotation(angle) {
                this.rotation = angle;
                
                const normalizedAngle = ((angle % 360) + 360) % 360;
                
                // Apply flip logic consistently - mesh flip and gradient use the same angle
                const needsFlip = normalizedAngle > 90 && normalizedAngle < 270;
                
                if (needsFlip) {
                    this.edgeContainer.style.transform = 'rotateY(180deg)';
                } else {
                    this.edgeContainer.style.transform = '';
                }
                
                this.updateGradient(angle, needsFlip);
                
                // Update front shine effect
                if (this.shineEffectFront) {
                    this.shineEffectFront.updateShinePosition(angle, this.isFlipping);
                    
                    let frontOpacity = 0;
                    // Convert to -180 to 180 range for opacity check
                    const angleForOpacity = ((angle + 180) % 360) - 180;
                    if (angleForOpacity >= -90 && angleForOpacity <= 90) {
                        frontOpacity = this.maxShineOpacity;
                    }
                    this.shineEffectFront.setOpacity(frontOpacity);
                }
                
                // Update back shine effect (opposite visibility)
                if (this.shineEffectBack) {
                    // For back face, invert the angle since it's rotated 180 degrees
                    const backAngle = angle + 180;
                    this.shineEffectBack.updateShinePosition(backAngle, this.isFlipping);
                    
                    let backOpacity = 0;
                    // Convert to -180 to 180 range for opacity check
                    const angleForOpacity = ((angle + 180) % 360) - 180;
                    if (angleForOpacity < -90 || angleForOpacity > 90) {
                        backOpacity = this.maxShineOpacity;
                    }
                    this.shineEffectBack.setOpacity(backOpacity);
                }
                
                // Check if we're currently hovering (has hover-rotate class)
                // During flip animation, always update transform (hover is disabled)
                const isHovering = !this.isFlipping && this.element.classList.contains('hover-rotate');
                
                if (isHovering) {
                    // If hovering (and not flipping), the hover handler will update the transform
                    // We don't update it here to preserve hover rotation
                    return;
                }
                
                // Otherwise, update the transform normally
                this.element.style.transform = `rotateY(${angle}deg)`;
            }
            
            updateGradient(rotationAngle, needsFlip) {
                const lightOffset = (rotationAngle / 360) * Math.PI * 2;
                const flipOffset = needsFlip ? Math.PI : 0;
                
                this.edgeSegments.forEach((segment, index) => {
                    const segmentAngle = (index / this.edgeSegments.length) * Math.PI * 2;
                    const lightAngle = segmentAngle + lightOffset + flipOffset;
                    
                    const mainReflection = Math.pow(Math.sin(lightAngle) * 0.5 + 0.5, 1.5);
                    const detailReflection = Math.sin(lightAngle * 5) * 0.25;
                    const highlight = Math.pow(Math.max(0, Math.sin(lightAngle)), 32) * 0.5;
                    
                    const reflectionValue = mainReflection + detailReflection + highlight;
                    const lightness = 25 + (reflectionValue * 75);
                    
                    segment.style.backgroundColor = `hsl(0, 0%, ${lightness}%)`;
                });
            }
            
            setThickness(thickness) {
                this.thickness = thickness;
                this.updateThickness();
            }
            
            animate() {
                if (!this.animating) return;
                
                // Stop animation if page is being hovered
                if (this.isPageHovered) return;
                
                this.rotation += this.animationSpeed;
                this.setRotation(this.rotation);
                
                const displayRotation = ((this.rotation + 180) % 360) - 180;
                document.getElementById('rotation').value = displayRotation;
                document.getElementById('rotationValue').textContent = Math.round(this.rotation);
                
                requestAnimationFrame(() => this.animate());
            }
            
            startAnimation() {
                this.animating = true;
                this.animate();
            }
            
            stopAnimation() {
                this.animating = false;
            }
            
            reset() {
                this.rotation = 0;
                this.setRotation(0);
                document.getElementById('rotation').value = 0;
                document.getElementById('rotationValue').textContent = 0;
            }
            
            flip() {
                if (this.isFlipping) return;
                
                this.isFlipping = true;
                this.hoverRotationDisabled = true; // Disable hover rotation during flip
                this.element.classList.add('flipping');
                
                // Immediately reset hover rotation values
                this.hoverRotationX = 0;
                this.hoverRotationY = 0;
                
                // Reset transform to base rotation (no hover rotation)
                const currentRotation = this.rotation;
                this.element.style.transform = `rotateY(${currentRotation}deg)`;
                this.element.classList.remove('hover-rotate');
                
                const targetRotation = this.rotation + 180;
                const startRotation = this.rotation;
                const startTime = performance.now();
                const duration = 1200;
                
                const animateFlip = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Use the same easing function for everything
                    const eased = progress === 1 ? 1 : 1 - Math.pow(2, -10 * progress);
                    
                    // Calculate eased rotation - this is the single source of truth
                    const easedRotation = startRotation + (180 * eased);
                    
                    // Use setRotation with the eased angle - it will handle mesh flip, gradient, and shine
                    // Everything follows the same eased rotation value
                    this.setRotation(easedRotation);
                    
                    // Update UI
                    const displayRotation = ((easedRotation + 180) % 360) - 180;
                    document.getElementById('rotation').value = displayRotation;
                    document.getElementById('rotationValue').textContent = Math.round(easedRotation);
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateFlip);
                    } else {
                        // Animation complete - set final rotation
                        this.rotation = targetRotation;
                        this.setRotation(targetRotation);
                        this.element.classList.remove('flipping');
                        this.isFlipping = false;
                        
                        // Re-enable hover rotation after a short delay
                        setTimeout(() => {
                            this.hoverRotationDisabled = false;
                        }, 300);
                    }
                };
                
                requestAnimationFrame(animateFlip);
            }
            
            createSilverVersion(imagePath) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.drawImage(img, 0, 0);
                        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        for (let i = 0; i < data.length; i += 4) {
                            const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                            data[i] = Math.min(255, gray * 0.95 + 20);
                            data[i + 1] = Math.min(255, gray * 0.97 + 20);
                            data[i + 2] = Math.min(255, gray + 25);
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                        resolve(canvas.toDataURL());
                    };
                    img.src = imagePath;
                });
            }
        }
        
        // =============================================================================
        // LIBRARY MANAGER
        // =============================================================================
        class MedalLibrary {
            constructor() {
                this.medal = new Medal3DCSS('medal');
                this.currentImageIndex = -1;
                this.thumbnailGrid = document.getElementById('thumbnailGrid');
                this.loadingOverlay = document.getElementById('loadingOverlay');
                
                this.init();
            }
            
            async init() {
                this.createThumbnails();
                document.getElementById('imageCount').textContent = `(${IMAGE_LIBRARY.length} medals)`;
                
                // Load first medal
                await this.loadMedal(0);
                
                // Start animation automatically
                this.medal.startAnimation();
            }
            
            createThumbnails() {
                this.thumbnailGrid.innerHTML = '';
                
                IMAGE_LIBRARY.forEach((filename, index) => {
                    const thumbnail = document.createElement('div');
                    thumbnail.className = 'thumbnail';
                    if (index === this.currentImageIndex) {
                        thumbnail.classList.add('active');
                    }
                    
                    const img = document.createElement('img');
                    img.src = `images/${filename}`;
                    img.alt = filename;
                    
                    const name = document.createElement('div');
                    name.className = 'thumbnail-name';
                    name.textContent = this.formatName(filename);
                    
                    thumbnail.appendChild(img);
                    thumbnail.appendChild(name);
                    
                    thumbnail.addEventListener('click', () => this.loadMedal(index));
                    
                    this.thumbnailGrid.appendChild(thumbnail);
                });
            }
            
            formatName(filename) {
                // Remove extension and replace underscores with spaces
                return filename
                    .replace(/\.[^/.]+$/, '')
                    .replace(/_/g, ' ')
                    .replace(/Badge conquistas /i, '')
                    .trim();
            }
            
            async loadMedal(index) {
                if (index === this.currentImageIndex) return;
                
                this.currentImageIndex = index;
                const filename = IMAGE_LIBRARY[index];
                const imagePath = `images/${filename}`;
                
                // Show loading
                this.loadingOverlay.classList.add('active');
                
                // Stop any animation
                this.medal.stopAnimation();
                
                // Update active thumbnail
                document.querySelectorAll('.thumbnail').forEach((thumb, i) => {
                    thumb.classList.toggle('active', i === index);
                });
                
                try {
                    await this.medal.loadMedal(imagePath, this.formatName(filename));
                } catch (e) {
                    console.error('Failed to load medal:', e);
                    document.getElementById('currentMedalName').textContent = 'Error loading medal';
                }
                
                // Hide loading
                this.loadingOverlay.classList.remove('active');
            }
        }
        
        // =============================================================================
        // INITIALIZE
        // =============================================================================
        let library;
        
        window.addEventListener('load', async () => {
            library = new MedalLibrary();
            
            // Dark mode toggle
            const darkModeToggle = document.getElementById('darkModeToggle');
            const isDarkMode = localStorage.getItem('darkMode') === 'true';
            
            if (isDarkMode) {
                document.body.classList.add('dark-mode');
                darkModeToggle.textContent = '‚òÄÔ∏è Light Mode';
            }
            
            darkModeToggle.addEventListener('click', () => {
                const isDark = document.body.classList.toggle('dark-mode');
                darkModeToggle.textContent = isDark ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
                localStorage.setItem('darkMode', isDark);
            });
            
            // Page hover detection - stop animation when hovering
            let hoverTimeout = null;
            
            document.addEventListener('mousemove', () => {
                // Mouse is moving on the page - pause animation
                library.medal.isPageHovered = true;
                
                // Clear any existing timeout
                if (hoverTimeout) {
                    clearTimeout(hoverTimeout);
                }
                
                // Set timeout to resume animation after mouse stops moving
                hoverTimeout = setTimeout(() => {
                    library.medal.isPageHovered = false;
                    // Resume animation if it was animating
                    if (library.medal.animating) {
                        library.medal.animate();
                    }
                }, 100); // Resume after 100ms of no mouse movement
            });
            
            document.addEventListener('mouseleave', () => {
                // Mouse left the page - resume animation immediately
                library.medal.isPageHovered = false;
                if (hoverTimeout) {
                    clearTimeout(hoverTimeout);
                    hoverTimeout = null;
                }
                // Resume animation if it was animating
                if (library.medal.animating) {
                    library.medal.animate();
                }
            });
            
            // Medal hover rotation effect
            const medalDisplay = document.querySelector('.medal-display');
            const medalElement = document.getElementById('medal');
            const scene = document.querySelector('.scene');
            let hoverRotationX = 0;
            let hoverRotationY = 0;
            const maxRotation = 15; // Maximum rotation in degrees
            
            // Store hover rotation values in medal object so flip() can reset them
            library.medal.hoverRotationX = 0;
            library.medal.hoverRotationY = 0;
            
            medalDisplay.addEventListener('mousemove', (e) => {
                // Don't apply hover rotation if medal is flipping or hover rotation is disabled
                if (library.medal.isFlipping || library.medal.hoverRotationDisabled) {
                    return;
                }
                
                const rect = scene.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                // Calculate mouse position relative to center (-1 to 1)
                const mouseX = (e.clientX - centerX) / (rect.width / 2);
                const mouseY = (e.clientY - centerY) / (rect.height / 2);
                
                // Calculate rotation angles (inverted Y for natural feel)
                // Smoothly interpolate to target rotation for easing
                const targetRotationY = mouseX * maxRotation;
                const targetRotationX = -mouseY * maxRotation;
                
                // Update stored values in medal object
                hoverRotationX = library.medal.hoverRotationX || 0;
                hoverRotationY = library.medal.hoverRotationY || 0;
                
                // Ease towards target rotation
                hoverRotationY += (targetRotationY - hoverRotationY) * 0.2;
                hoverRotationX += (targetRotationX - hoverRotationX) * 0.2;
                
                // Store updated values
                library.medal.hoverRotationX = hoverRotationX;
                library.medal.hoverRotationY = hoverRotationY;
                
                // Apply hover rotation class for smooth transition
                medalElement.classList.add('hover-rotate');
                
                // Get current rotation from the medal
                const currentRotation = library.medal.rotation;
                
                // Combine current rotation with hover rotation
                medalElement.style.transform = `rotateY(${currentRotation + hoverRotationY}deg) rotateX(${hoverRotationX}deg)`;
            });
            
            medalDisplay.addEventListener('mouseleave', () => {
                hoverRotationX = 0;
                hoverRotationY = 0;
                library.medal.hoverRotationX = 0;
                library.medal.hoverRotationY = 0;
                medalElement.classList.remove('hover-rotate');
                
                // Reset to just the current rotation
                const currentRotation = library.medal.rotation;
                medalElement.style.transform = `rotateY(${currentRotation}deg)`;
            });
            
            // Controls
            document.getElementById('rotation').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('rotationValue').textContent = Math.round(value);
                library.medal.setRotation(value);
            });
            
            document.getElementById('thickness').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('thicknessValue').textContent = value;
                library.medal.setThickness(value);
            });
            
            document.getElementById('speed').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = value.toFixed(1);
                library.medal.animationSpeed = value;
            });
            
            document.getElementById('animate').addEventListener('click', () => {
                library.medal.startAnimation();
            });
            
            document.getElementById('stop').addEventListener('click', () => {
                library.medal.stopAnimation();
            });
            
            document.getElementById('reset').addEventListener('click', () => {
                library.medal.stopAnimation();
                library.medal.reset();
            });
            
            // Shine Effect Controls
            document.getElementById('shineAngle').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('shineAngleValue').textContent = value;
                if (library.medal.shineEffectFront) {
                    library.medal.shineEffectFront.updateGradientAngle(value);
                }
                if (library.medal.shineEffectBack) {
                    library.medal.shineEffectBack.updateGradientAngle(value);
                }
            });
            
            document.getElementById('shineBlur').addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                document.getElementById('shineBlurValue').textContent = value;
                if (library.medal.shineEffectFront) {
                    library.medal.shineEffectFront.setBlur(value);
                }
                if (library.medal.shineEffectBack) {
                    library.medal.shineEffectBack.setBlur(value);
                }
            });
            
            document.getElementById('maskContrast').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('maskContrastValue').textContent = value.toFixed(1);
                if (library.medal.shineEffectFront) {
                    library.medal.shineEffectFront.maskContrast = value;
                }
                if (library.medal.shineEffectBack) {
                    library.medal.shineEffectBack.maskContrast = value;
                }
            });
            
            document.getElementById('shineOpacity').addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                document.getElementById('shineOpacityValue').textContent = value.toFixed(2);
                library.medal.maxShineOpacity = value;
                library.medal.setRotation(library.medal.rotation);
            });
            
            document.getElementById('regenerateMask').addEventListener('click', async () => {
                if (!library.medal.shineEffectFront || !library.medal.shineEffectBack) return;
                
                const btn = document.getElementById('regenerateMask');
                btn.disabled = true;
                btn.textContent = '‚è≥ Regenerating...';
                
                try {
                    await Promise.all([
                        library.medal.shineEffectFront.generateLightnessMask(),
                        library.medal.shineEffectBack.generateLightnessMask()
                    ]);
                    library.medal.shineEffectFront.applyMask();
                    library.medal.shineEffectBack.applyMask();
                    
                    btn.textContent = '‚úì Mask Regenerated!';
                    setTimeout(() => {
                        btn.textContent = 'üîÑ Regenerate Shine Mask';
                        btn.disabled = false;
                    }, 2000);
                } catch (e) {
                    console.error('Failed to regenerate mask:', e);
                    btn.textContent = '‚ùå Error - Try Again';
                    btn.disabled = false;
                }
            });
        });
    </script>
</body>
</html>
