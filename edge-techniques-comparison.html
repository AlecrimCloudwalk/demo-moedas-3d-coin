<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edge Rendering Techniques Comparison</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .subtitle {
            text-align: center;
            opacity: 0.8;
            margin-bottom: 30px;
        }
        
        .techniques-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .technique-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        .technique-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffd700;
        }
        
        .technique-desc {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        
        .scene {
            width: 100%;
            height: 350px;
            perspective: 1000px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        
        .medal-3d {
            width: 280px;
            height: 280px;
            position: relative;
            transform-style: preserve-3d;
        }
        
        .medal-face {
            position: absolute;
            width: 100%;
            height: 100%;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            backface-visibility: hidden;
        }
        
        .medal-front {
            transform: translateZ(15px);
        }
        
        .medal-back {
            transform: translateZ(-15px) rotateY(180deg);
        }
        
        /* Technique 1: SVG Path */
        .edge-svg {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
        }
        
        .edge-svg svg {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: rotateY(90deg);
            transform-origin: center;
        }
        
        /* Technique 2: Canvas */
        .edge-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            transform: rotateY(90deg);
            transform-origin: center;
            transform-style: preserve-3d;
        }
        
        /* Technique 3: Extruded Polygon */
        .edge-polygon {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
        }
        
        .edge-slice {
            position: absolute;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
        }
        
        /* Technique 4: CSS Mask */
        .edge-mask {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                rgb(180, 160, 140) 0%,
                rgb(140, 120, 100) 25%,
                rgb(100, 85, 70) 50%,
                rgb(140, 120, 100) 75%,
                rgb(180, 160, 140) 100%
            );
            transform: rotateY(90deg);
            transform-origin: center;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            margin-top: 20px;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .control-row label {
            min-width: 100px;
        }
        
        input[type="range"] {
            flex: 1;
        }
        
        .value-display {
            min-width: 60px;
            text-align: right;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        .pros-cons {
            margin-top: 10px;
            font-size: 11px;
            line-height: 1.5;
        }
        
        .pros {
            color: #90EE90;
        }
        
        .cons {
            color: #FFB6C6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¨ Edge Rendering Techniques Comparison</h1>
        <p class="subtitle">Compare different approaches to render the medal edge/extrusion</p>
        
        <div class="techniques-grid">
            <!-- Technique 1: SVG Path -->
            <div class="technique-card">
                <div class="technique-title">1. SVG Path with Gradient</div>
                <div class="technique-desc">Single SVG path following outline, CSS gradient fill</div>
                <div class="scene">
                    <div class="medal-3d" id="medal-svg">
                        <div class="medal-front medal-face"></div>
                        <div class="edge-svg" id="edge-svg-container"></div>
                        <div class="medal-back medal-face"></div>
                    </div>
                </div>
                <div class="pros-cons">
                    <div class="pros">âœ“ Single shape, one gradient<br>âœ“ Smooth vector rendering<br>âœ“ Very performant</div>
                    <div class="cons">âœ— Complex gradient positioning<br>âœ— Limited 3D depth illusion</div>
                </div>
            </div>
            
            <!-- Technique 2: Canvas -->
            <div class="technique-card">
                <div class="technique-title">2. Canvas 2D</div>
                <div class="technique-desc">Draw edge on canvas with custom gradients and shading</div>
                <div class="scene">
                    <div class="medal-3d" id="medal-canvas">
                        <div class="medal-front medal-face"></div>
                        <canvas class="edge-canvas" id="edge-canvas" width="280" height="280"></canvas>
                        <div class="medal-back medal-face"></div>
                    </div>
                </div>
                <div class="pros-cons">
                    <div class="pros">âœ“ Full drawing control<br>âœ“ Complex gradients easy<br>âœ“ Per-pixel control</div>
                    <div class="cons">âœ— Rasterized (not vector)<br>âœ— Needs redraw on resize</div>
                </div>
            </div>
            
            <!-- Technique 3: Layered Polygons -->
            <div class="technique-card">
                <div class="technique-title">3. Layered Depth Slices</div>
                <div class="technique-desc">Multiple layers at different Z positions with clip-path</div>
                <div class="scene">
                    <div class="medal-3d" id="medal-layers">
                        <div class="medal-front medal-face"></div>
                        <div class="edge-polygon" id="edge-polygon-container"></div>
                        <div class="medal-back medal-face"></div>
                    </div>
                </div>
                <div class="pros-cons">
                    <div class="pros">âœ“ True depth perception<br>âœ“ Natural lighting<br>âœ“ CSS animations work</div>
                    <div class="cons">âœ— More DOM elements<br>âœ— Complex setup</div>
                </div>
            </div>
            
            <!-- Technique 4: Simple Mask -->
            <div class="technique-card">
                <div class="technique-title">4. CSS Mask/Clip-Path</div>
                <div class="technique-desc">Use mask-image or clip-path to shape a gradient rectangle</div>
                <div class="scene">
                    <div class="medal-3d" id="medal-mask">
                        <div class="medal-front medal-face"></div>
                        <div class="edge-mask" id="edge-mask-container"></div>
                        <div class="medal-back medal-face"></div>
                    </div>
                </div>
                <div class="pros-cons">
                    <div class="pros">âœ“ Simplest code<br>âœ“ Hardware accelerated<br>âœ“ Easy gradient</div>
                    <div class="cons">âœ— Harder irregular shapes<br>âœ— Limited control</div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <label>Rotation:</label>
                <input type="range" id="rotation" min="-180" max="180" value="45" step="1">
                <span class="value-display"><span id="rotationValue">45</span>Â°</span>
            </div>
            <div class="control-row">
                <label>Thickness:</label>
                <input type="range" id="thickness" min="5" max="50" value="15" step="1">
                <span class="value-display"><span id="thicknessValue">15</span>px</span>
            </div>
        </div>
    </div>
    
    <script>
        // Load medal image and extract outline
        async function extractOutline(imagePath) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, img.width, img.height);
                    const data = imageData.data;
                    
                    const centerX = img.width / 2;
                    const centerY = img.height / 2;
                    const points = [];
                    
                    // Extract outline
                    for (let i = 0; i < 120; i++) {
                        const angle = (i / 120) * Math.PI * 2;
                        const dx = Math.cos(angle);
                        const dy = Math.sin(angle);
                        
                        let maxR = 0;
                        for (let r = 0; r < Math.max(img.width, img.height) / 2; r++) {
                            const x = Math.floor(centerX + dx * r);
                            const y = Math.floor(centerY + dy * r);
                            if (x >= 0 && x < img.width && y >= 0 && y < img.height) {
                                const idx = (y * img.width + x) * 4;
                                if (data[idx + 3] > 128) maxR = r;
                            }
                        }
                        
                        points.push({
                            angle,
                            x: dx * maxR,
                            y: dy * maxR,
                            radius: maxR
                        });
                    }
                    
                    resolve({ points, imageSize: Math.max(img.width, img.height) });
                };
                img.src = imagePath;
            });
        }
        
        // Technique 1: SVG Path
        function createSVGEdge(container, outline) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 280 280');
            
            const scale = 280 / outline.imageSize;
            const centerX = 140;
            const centerY = 140;
            
            // Create path
            let pathData = '';
            outline.points.forEach((point, i) => {
                const x = centerX + point.x * scale;
                const y = centerY + point.y * scale;
                pathData += i === 0 ? `M ${x} ${y}` : ` L ${x} ${y}`;
            });
            pathData += ' Z';
            
            // Create gradient
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient.setAttribute('id', 'edgeGradient');
            gradient.setAttribute('x1', '0%');
            gradient.setAttribute('y1', '0%');
            gradient.setAttribute('x2', '100%');
            gradient.setAttribute('y2', '0%');
            
            const stops = [
                { offset: '0%', color: 'rgb(180, 160, 140)' },
                { offset: '25%', color: 'rgb(140, 120, 100)' },
                { offset: '50%', color: 'rgb(100, 85, 70)' },
                { offset: '75%', color: 'rgb(140, 120, 100)' },
                { offset: '100%', color: 'rgb(180, 160, 140)' }
            ];
            
            stops.forEach(s => {
                const stop = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop.setAttribute('offset', s.offset);
                stop.setAttribute('stop-color', s.color);
                gradient.appendChild(stop);
            });
            
            defs.appendChild(gradient);
            svg.appendChild(defs);
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('fill', 'url(#edgeGradient)');
            path.setAttribute('stroke', 'rgba(0,0,0,0.2)');
            path.setAttribute('stroke-width', '1');
            
            svg.appendChild(path);
            container.appendChild(svg);
        }
        
        // Technique 2: Canvas
        function createCanvasEdge(canvas, outline) {
            const ctx = canvas.getContext('2d');
            const scale = 280 / outline.imageSize;
            const centerX = 140;
            const centerY = 140;
            
            ctx.clearRect(0, 0, 280, 280);
            
            // Create path
            ctx.beginPath();
            outline.points.forEach((point, i) => {
                const x = centerX + point.x * scale;
                const y = centerY + point.y * scale;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.closePath();
            
            // Create radial gradient for depth
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 140);
            gradient.addColorStop(0, 'rgb(180, 160, 140)');
            gradient.addColorStop(0.5, 'rgb(140, 120, 100)');
            gradient.addColorStop(1, 'rgb(100, 85, 70)');
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Add lighting effect
            outline.points.forEach((point, i) => {
                const nextPoint = outline.points[(i + 1) % outline.points.length];
                const x1 = centerX + point.x * scale;
                const y1 = centerY + point.y * scale;
                
                // Calculate lighting
                const lightAngle = 135 * Math.PI / 180;
                const normalAngle = point.angle + Math.PI / 2;
                const brightness = Math.cos(normalAngle - lightAngle) * 30 + 140;
                
                ctx.strokeStyle = `rgba(${brightness * 1.2}, ${brightness}, ${brightness * 0.8}, 0.3)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x1, y1);
                ctx.stroke();
            });
        }
        
        // Technique 3: Layered Polygons
        function createLayeredEdge(container, outline) {
            const scale = 280 / outline.imageSize;
            const layers = 5;
            
            for (let layer = 0; layer < layers; layer++) {
                const slice = document.createElement('div');
                slice.className = 'edge-slice';
                
                const z = (layer / layers) * 30 - 15;
                const brightness = 100 + (layer / layers) * 80;
                
                // Create clip-path polygon
                let clipPath = 'polygon(';
                outline.points.forEach((point, i) => {
                    const x = 50 + (point.x * scale / 280) * 100;
                    const y = 50 + (point.y * scale / 280) * 100;
                    clipPath += `${x}% ${y}%${i < outline.points.length - 1 ? ', ' : ''}`;
                });
                clipPath += ')';
                
                slice.style.clipPath = clipPath;
                slice.style.background = `rgb(${brightness * 1.4}, ${brightness * 1.2}, ${brightness})`;
                slice.style.transform = `translateZ(${z}px) rotateY(90deg)`;
                
                container.appendChild(slice);
            }
        }
        
        // Technique 4: CSS Mask
        function createMaskEdge(container, outline) {
            const scale = 280 / outline.imageSize;
            
            // Create clip-path from outline
            let clipPath = 'polygon(';
            outline.points.forEach((point, i) => {
                const x = 50 + (point.x * scale / 280) * 100;
                const y = 50 + (point.y * scale / 280) * 100;
                clipPath += `${x}% ${y}%${i < outline.points.length - 1 ? ', ' : ''}`;
            });
            clipPath += ')';
            
            container.style.clipPath = clipPath;
        }
        
        // Initialize
        let outline;
        
        window.addEventListener('load', async () => {
            outline = await extractOutline('images/medal2.png');
            
            // Set medal images
            document.querySelectorAll('.medal-front').forEach(el => {
                el.style.backgroundImage = 'url(images/medal2.png)';
            });
            
            // Create silver back
            const silverBack = await createSilverVersion('images/medal2.png');
            document.querySelectorAll('.medal-back').forEach(el => {
                el.style.backgroundImage = `url(${silverBack})`;
            });
            
            // Initialize each technique
            createSVGEdge(document.getElementById('edge-svg-container'), outline);
            createCanvasEdge(document.getElementById('edge-canvas'), outline);
            createLayeredEdge(document.getElementById('edge-polygon-container'), outline);
            createMaskEdge(document.getElementById('edge-mask-container'), outline);
            
            // Controls
            const rotationSlider = document.getElementById('rotation');
            const thicknessSlider = document.getElementById('thickness');
            
            function updateAll() {
                const rotation = parseFloat(rotationSlider.value);
                const thickness = parseFloat(thicknessSlider.value);
                
                document.getElementById('rotationValue').textContent = Math.round(rotation);
                document.getElementById('thicknessValue').textContent = thickness;
                
                // Update all medals
                document.querySelectorAll('.medal-3d').forEach(medal => {
                    medal.style.transform = `rotateY(${rotation}deg)`;
                    
                    // Update face positions
                    medal.querySelector('.medal-front').style.transform = `translateZ(${thickness/2}px)`;
                    medal.querySelector('.medal-back').style.transform = `translateZ(-${thickness/2}px) rotateY(180deg)`;
                });
            }
            
            rotationSlider.addEventListener('input', updateAll);
            thicknessSlider.addEventListener('input', updateAll);
            
            updateAll();
        });
        
        // Helper: Create silver version
        function createSilverVersion(imagePath) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                        data[i] = Math.min(255, gray * 0.95 + 20);
                        data[i + 1] = Math.min(255, gray * 0.97 + 20);
                        data[i + 2] = Math.min(255, gray + 25);
                    }
                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas.toDataURL());
                };
                img.src = imagePath;
            });
        }
    </script>
</body>
</html>

